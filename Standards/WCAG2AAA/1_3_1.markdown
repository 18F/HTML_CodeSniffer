---
title: Success Criterion 1.3.1, Info and Relationships
layout: default
---

# Success Criterion 1.3.1: Info and Relationships

- **Applies to**: <abbr title="Single A">A</abbr>, <abbr title="Double A">AA</abbr>, <abbr title="Triple A">AAA</abbr>

## Definition

Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.

The full ["understanding" page for Success Criterion 1.3.1](http://www.w3.org/TR/UNDERSTANDING-WCAG20/content-structure-separation-programmatic.html) is available from the W3C.

Information that is conveyed using colour alone falls under "Success Criterion 1.4.1 - Use of Colour" instead. Although the value of the colour can be programmatically determined, this value alone does not convey information. A text alternative is required in this case.

## Techniques tested

### Table of contents

- [Correct association of table headers with data cells in data tables](#tech-h43h63)
- [H42: Using h1-h6 to identify headings](#tech-h42)
- [H44: Using label elements to associate text labels with form controls](#tech-h44)
- [H49: Using semantic markup to mark emphasized or special text](#tech-h49)

### <a id="tech-h43h63">Correct association of data cells with header cells in data tables</a>

Includes the following techniques:

- [H63: Using the scope attribute to associate header cells and data cells in data tables](http://www.w3.org/TR/2010/NOTE-WCAG20-TECHS-20101014/H63)
- [H43: Using id and headers attributes to associate data cells with header cells in data tables](http://www.w3.org/TR/2010/NOTE-WCAG20-TECHS-20101014/H43)

Both of these techniques aim to apply the same concept of ensuring that data cells in a data table can be associated with the correct headers. This provides context for data cells, which can be used by screen readers as they go through a table.

The headers attribute (technique H43) is primarily recommended for complex tables with two or more levels of headings. If this is the case for a data table, then all cells must be labelled with a headers attribute, and all table headings with an id attribute to allow them to be referenced. Scope attribute becomes ambiguous and thus is not applicable to this type of table.

Where there is only one row and one column of headers, the scope attribute (technique H63) is the recommended option - however, using the headers attribute as above is also acceptable. This especially applies when the header is not in the first row or column. The scope attribute allows a header cell to be specified as being applicable either to a row or a column (or in rarer cases, for a row group or column group - represented by a tbody or colgroup element respectively). Use of scope for row and col has reasonable support by assistive technology but for rowgroup and colgroup is less consistent.

The scope attributes technique states that for "simple tables", using th and td without any further identification is enough. However, the definition of "simple table" becomes ambiguous. The technique speaks of simple tables with one row *or* column header, but then talks about it being useful to tables where the main header is not in the first row or column - which suggests that a table with one row *and*
one column of headers can be "simple" as long as they are in the first row/column - but this is not made clear.

To avoid ambiguity, HTMLCodeSniffer takes it to mean "one row *or* one column heading, but not both". Where there is one of each, some association is required - whether that is through the scope or headers attributes.

The approach taken by HTMLCodeSniffer as to which technique(s) are acceptable and/or required:

- If there are two rows and/or two columns of headings, use of the headers attribute is required (as scope becomes ambiguous).
- With exactly one row and one column of headings, either headers on all td cells -or- scope on all headers will be accepted.
- With one single row or column of headings but not both, neither is required.

A "row" or "column" of headings is determined on the basis of having more than one th element in a row. This is a sufficient definition - even though having two columns in one direction (say) will trigger this in every row, by then we already know that we need headers attributes.

#### Testing

##### Scope attribute (H63)

1.  Check that all th elements have a scope attribute.
2.  Check that all td elements that act as headers for other elements have a scope attribute.
3.  Check that all scope attributes have the value row, col, rowgroup, or colgroup.

##### Headers attribute (H43)

1.  Check for layout tables: determine whether the content has a relationship with other content in both its column and its row. If Òno," the table is a layout table. If Òyes," the table is a data table.
2.  For data tables, check that any cell that is associated with more than one row and/or one column header contains a headers attribute that lists the id for all headers associated with that cell.
3.  For data tables where any cell contains an id or headers attribute,
    a. Check that each id listed in the headers attribute of the data cell matches the id attribute of a cell that is used as a header element
    b. Check that the headers attribute of a data cell contains the id attribute of all headers associated with the data cell
    c. Check that all ids are unique (that is, no two elements in the page have the same id)

#### Examples

1.  No attribute required.

        <table>
            <tr>
                <th>Alpha</th>
                <th>Beta</th>
            </tr>
            <tr>
                <td>Cell A</td>
                <td>Cell B</td>
            </tr>
        </table>

1.  One row and one column, with scope attributes applied.

        <table>
            <tr>
                <th scope="col">Column</th>
                <th scope="col">Alpha</th>
                <th scope="col">Beta</th>
            </tr>
            <tr>
                <th scope="row">Name</th>
                <td>Cell A</td>
                <td>Cell B</td>
            </tr>
        </table>

1.  One row and one column, with headers attributes applied.

        <table>
            <tr>
                <th id="col">Column</th>
                <th id="alpha">Alpha</th>
                <th id="beta">Beta</th>
            </tr>
            <tr>
                <th id="name">Name</th>
                <td headers="alpha name">Cell A</td>
                <td headers="beta name">Cell B</td>
            </tr>
        </table>


1.  Two levels of column headings. The headers attribute is required.

        <table>
            <tr>
                <th colspan="2" id="alpha">Alpha</th>
                <th rowspan="2" id="beta">Beta</th>
            </tr>
            <tr>
                <th id="alpha-1">Alpha 1</th>
                <th id="alpha-2">Alpha 2</th>
            </tr>
            <tr>
                <td headers="alpha alpha-1">Cell A1</td>
                <td headers="alpha alpha-2">Cell A2</td>
                <td headers="beta">Cell B</td>
            </tr>
        </table>


1.  Two levels of column headings, with a column-spanned data cell. The headers attribute is required, and the spanned cell needs all headings specified.

        <table>
            <tr>
                <th colspan="2" id="alpha">Alpha</th>
                <th rowspan="2" id="beta">Beta</th>
            </tr>
            <tr>
                <th id="alpha-1">Alpha 1</th>
                <th id="alpha-2">Alpha 2</th>
            </tr>
            <tr>
                <td colspan="2" headers="alpha alpha-1 alpha-2">Cell A1+2</td>
                <td headers="beta">Cell B</td>
            </tr>
        </table>

#### Errors

#### Warnings

### <a id="tech-h42">H42: Using h1-h6 to identify headings</a>

"The objective of this technique is to use HTML and XHTML heading markup to provide semantic code for headings in the content."

#### Testing

> 1. Check that heading markup is used when content is a heading.
> 2. Check that heading markup is not used when content is not a heading.

Not very helpful - it's not easy to determine what is a heading or and what is not.

The following inferences can probably be made, using warnings to alert the user to a potential header or misuse of headers:

- A paragraph that is immediately wrapped with a strong/em tag or some other styling, is probably a candidate for flagging as a potential heading.
- A large amount of text without headings might throw a warning that you may need to implement headings. (This might be applicable more to technique H69 - providing section headings - than this one.)
- Perhaps if a paragraph is unstyled and looks like a single sentence fragment, we could warn as to whether it should be a heading.

#### Examples

### <a id="tech-h44">H44: Using label elements to associate text labels with form controls</a>

This also applies to Success Criteria [1.1.1 - Info and Relationships](./1_1_1), 3.3.2 - Labels and Instructions, and 4.1.2 - Name, Role, Value; all of which apply at the <abbr title="Single A">A</abbr> level.

#### Testing

> 1. Check that there is a label element that identifies the purpose of the control (before/after) the applicable element.
> 2. Check that the for attribute of the label element matches the id of the applicable element.
> 3. Check that the label element is visible.

Items 1 and 2 are sufficient, except for Success Criterion 3.3.2 - Labels and Instructions, where item 3 is also necessary.

##### Position of label

The test criteria are split into two parts, based on the position the label should be located relative to the control. This is desired in the case of user-agents that do not support associating labels with controls: the text provided is at least in an expected place on the interface.

The label should be displayed *before* the control element for inputs generally manifesting themselves as a textual input (input element with type "text", "password" and "file"; and the textarea element), and for drop-down select boxes (select element).

The label should be displayed *after* the control element for radio buttons and check boxes (input element with type "radio" or "checkbox").

Note that "before" and "after" generally refer to the left and right hand sides (respectively) of the control when writing in Latin script, but would be reversed where the writing direction is right-to-left.

##### How far before/after?

The technique does not state *how far* before or after the element the label should appear. General technique [G162: Positioning labels to maximize predictability of relationships](http://www.w3.org/TR/2010/NOTE-WCAG20-TECHS-20101014/G162). This states "immediately before" and "immediately after", where "before" can also include directly above the field (so the label and text field line up).

Also relevant is the [interim checkpoint 10.2](http://www.w3.org/TR/WCAG10/#tech-unassociated-labels) (at <abbr title="Double A">AA</abbr> level) in <acronym title="Web Content Accessibility Guidelines">WCAG</acronym> 1.0, stating that until label/control associations are supported (using the "for" attribute for instance):

> The label must immediately precede its control on the same line (allowing more than one control/label per line) or be in the line preceding the control (with only one label and one control per line).

This interim checkpoint probably no longer applies due to improved abilities of browsers and assistive technology, but is a good starting point for determining what is acceptable.

Currently, HTMLCodeSniffer makes no judgement call on the distance of the label from the control, as long as it is before or after the appropriate control element in the DOM. Testing for relative position is difficult, because the label could be wrapped in other elements and therefore unable to be found on the same level as the control. If a style sheet then moves the label to an "incorrect" position, this then should be marked as a manual fail.

##### No label required

Further, the description for this technique states which elements should **not** have a label element - since the control itself provides a label, or the control has no visual implementation.

Elements that should **not** have a label element include buttons of various types (input element with type "submit", "reset", or "image", and button element), and hidden fields (input element with type "hidden").

#### Errors

1.  A label element exists for a control that is a button-type element or a hidden field.
    In the case of buttons, the label is provided in another way (value, alt text, element contents). In the case of hidden fields, labels make no sense since there is no visual representation.

    Example:

    Each of these controls should return an error based on being not a type of element that accepts a label of its own.

        <form>
            <p><label for="submitInput">Submit Form:</label> <input type="reset" id="submitInput" value="Submit Form" /></p>
            <p><label for="resetInput">Reset Form:</label> <input type="reset" id="resetInput" value="Reset Form" /></p>
            <p><label for="imageSubmit">Next Page:</label> <input type="image" src="next.png" alt="Proceed to Next Page" id="imageSubmit" /></p>
            <p><label for="buttonField">Click Me:</label> <button id="buttonField">Click Me</button></p>
            <p><label for="hiddenField">Hidden Field:</label> <input type="hidden" id="hiddenField" value="hideme" /></p>
        </form>

1.  A label element exists without a "for" attribute.
    This implies an "implicit label" that would be wrapped around an input. Assistive technology handles this inconsistently, so is not recommended.
    H44 mandates that labels be associated explicitly with a control, using the "for" attribute.

    Example:

        <form>
            <label>First Name:
                <input type="text" id="firstName" />
            </label>
        </form>

1.  A form control does not have an "id" attribute, thereby precluding it from having an explicit label
    It's a good idea for other reasons too, of course.

    Example:

        <form>
            First Name: <input type="text" name="firstName" />
        </form>

1.  A form control uses an "id" attribute, but there is no label element with the same "for" attribute. There is also no "title" attribute on the control.

    Example:

        <form>
            <input type="text" id="firstName" />
        </form>

1.  A form control uses an "id" attribute, but there is no label element with the same "for" attribute. There is a "title" attribute on the control, but it is blank.

    Example:

        <form>
            <input type="text" id="firstName" title="" />
        </form>

    Example:

    White space alone should not be considered a pass.

        <form>
            <input type="text" id="firstName" title="   " />
        </form>

1.  A form control has a valid label attached, but it is not in an appropriate position relative to the form control.
    HTMLCodeSniffer tests this in relation to the DOM, which should satisfy most scenarios where text is running in a single direction. (whether it be <abbr title="left-to-right">LTR</abbr> or <abbr title="right-to-left">RTL</abbr>).

    Example:

    Labels for text boxes should be before inputs.

        <form>
            <input type="text" id="firstName" />
            <label for="firstName">First Name</label>
        </form>

        Example:

    Example:

    Labels for check boxes should follow inputs.

        <form>
            <label for="saveAsNew">Save as New:</label>
            <input type="checkbox" id="saveAsNew" checked="checked" />
        </form>

#### Warnings

1.  A label element does not exist for a control, but a title attribute exists on the control and is not empty.
    This is emitted as [technique H65](http://www.w3.org/TR/2010/NOTE-WCAG20-TECHS-20101014/H65).
    A manual tester should ensure that the title identifies the purpose of the control (as the label element would), AND that a label element is not feasible for the situation.

    Example:

    A title element is appropriate, since the purpose of the controls are generally
    identified visually by the "Search" button text. This could probably be improved
    by wrapping both fields in a fieldset element, but that is outside the scope of
    this technique.

        <form>
            <input type="text" id="testInput" title="Search Text" />
            <button type="submit">Search</button>
        </form>

    Example:

    This probably would be manually failed because there is no reason why a label
    element couldn't be used.

        <form>
            <input type="text" id="testInput" title="Test Input" />
        </form>

#### Notices

1.  Where a label is correctly associated and placed in the correct position in the DOM, a notice will be thrown for the tester, as manual tests are still required, namely:

      - that the label describes the purpose of the control.
      - that the label is correctly positioned visually as well as DOM-wise. (If CSS is used to move it to the wrong place, for instance, or the label is too detached from the control.)

    Examples of correct label association and placement, which will emit a notice:

        <!-- Correct label position before element. -->
        <p><label for="testInput">Test Input:</label><input type="text" id="testInput" /></p>
        <p><label for="testTextArea">Test Input:</label><textarea id="testTextArea">
            Sample Text
        </textarea></p>
        <p><label for="testSelect">Test Select:</label><select id="testSelect">
            <option>Apples</option>
            <option>Oranges</option>
        </select></p>

        <!-- White space is acceptable. -->
        <p><label for="testInput">Test Input:</label>  <input type="text" id="testInput" /></p>

        <!-- As should be line breaks (but only with labels placed "before"). -->
        <p><label for="testInput">Test Input:</label><br/>
        <input type="text" id="testInput" /></p>

        <!-- Correct label position after element. -->
        <p><input type="checkbox" id="testInput" checked="checked" /><label for="testInput">Test Input</label></p>
        <p><input type="radio" id="testRadio" />  <label for="testRadio">Test Radio 1</label></p>

    Example of potential manual fail:

        <p><input type="checkbox" id="testInput" checked="checked" /><br/><label for="testInput">Test Input</label></p>

    Example of potential manual fail:

    Example of a text box representing a date. The instructions that the date should
    be entered in "<abbr title="Day Month Year">dd/mm/yyyy</abbr>" format is
    important information that should be contained either in the label or as a title
    attribute (as per [technique G89: "Providing expected data format and example"](http://www.w3.org/TR/2010/NOTE-WCAG20-TECHS-20101014/G89)).

        <p><label for="dateField">Enter Date:</label><br/>
        <input type="text" id="dateField" /> (in <abbr title="Day Month Year">dd/mm/yyyy</abbr> format)</p>

### <a id="tech-h49">H49: Using semantic markup to mark emphasized or special text</a>

In HTML 4 (and therefore XHTML 1.0), tags such as b, i, u, tt and others are defined as presentational elements, as opposed to "structured text" elements like em, strong, code, kbd and the like. The presentational tags do not convey any purpose beyond presentation and are therefore of little use to assistive technology.

> Note, however, that in HTML5 tags such as b, i, u are defined in semantic terms and thus may still be considered valid, however they are defined as a "last resort" to better-matched semantic tags.

#### Related Reading

- [Phrase elements as defined by HTML 4](http://www.w3.org/TR/html4/struct/text.html#h-9.2.1). This covers em, strong, code, etc as part of "structured text".
- [Font-style elements defined by HTML 4](http://www.w3.org/TR/html4/present/graphics.html#h-15.2.1). This covers b, i, u, etc in purely presentational terms.
- [Text-level semantics in HTML5 Working Draft](http://dev.w3.org/html5/spec/Overview.html#text-level-semantics).

#### Testing

> 1. Examine the content for information that is conveyed through variations in presentation of text.
> 2. Check that appropriate semantic markup (such as em, strong, cite, blockquote, quote, sub, and sup) have been used to mark the text that conveys information through variations in text.

At the very least, we check for use of presentational markup where semantic markup should be used (tags such as b, i, u).

Where a remedy is to be provided, keep in mind that replacing the tags directly based on presentation (eg. directly replacing i with em) may not always be the most appropriate, if the meaning of the semantic tag is not respected.

Example 1: you have been using italics to markup inline quotes presentationally. In this case, it would be more semantically sound to markup the quote using the q tag.

Example 2: you have been bolding text (using b) to emphasise, but the emphasis is not strong enough to consider "strong" - say, your stronger emphasis is bold text plus a colour. It may be more semantically sound to replace that b with em (and not strong) and then style em as bold text through CSS.

That's not to say that the above conversion won't happen in most cases. However, this should not occur automatically, if accessibility and semantics are kept in mind.

#### Examples


